
import { GoogleGenAI, Type } from "@google/genai";
import { GenerationConfig, EbookOutline, ElementType, Ebook, EbookPage, EbookElement } from "./types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const generateOutline = async (config: GenerationConfig): Promise<EbookOutline> => {
  const prompt = `Create a structured ebook outline for the topic: "${config.topic}". 
  Target audience: ${config.audience}. 
  Tone: ${config.tone}. 
  Ebook length preference: ${config.length}. 
  Include a title, subtitle, and detailed chapters with subsections.`;

  const response = await ai.models.generateContent({
    model: "gemini-3-flash-preview",
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING },
          subtitle: { type: Type.STRING },
          chapters: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                title: { type: Type.STRING },
                subsections: { type: Type.ARRAY, items: { type: Type.STRING } },
                keyPoints: { type: Type.ARRAY, items: { type: Type.STRING } },
              },
              required: ["title", "subsections", "keyPoints"]
            }
          }
        },
        required: ["title", "subtitle", "chapters"]
      }
    }
  });

  return JSON.parse(response.text || "{}") as EbookOutline;
};

export const generatePageLayout = async (chapter: any, pageIndex: number): Promise<any> => {
  const prompt = `Generate a visual layout for page ${pageIndex} of an ebook based on the chapter "${chapter.title}".
  Return a JSON structure representing UI elements with positioning (x, y, w, h) and styles.
  Include meaningful text content for paragraphs and headings.`;

  const response = await ai.models.generateContent({
    model: "gemini-3-pro-preview",
    contents: prompt,
    config: {
      thinkingConfig: { thinkingBudget: 2000 },
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          backgroundColor: { type: Type.STRING },
          elements: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                type: { type: Type.STRING, description: "title, heading, paragraph, quote, or image" },
                content: { type: Type.STRING },
                x: { type: Type.NUMBER },
                y: { type: Type.NUMBER },
                w: { type: Type.NUMBER },
                h: { type: Type.NUMBER },
                style: {
                  type: Type.OBJECT,
                  properties: {
                    fontSize: { type: Type.NUMBER },
                    textAlign: { type: Type.STRING },
                    color: { type: Type.STRING }
                  }
                }
              },
              required: ["type", "content", "x", "y", "w", "h"]
            }
          }
        }
      }
    }
  });

  return JSON.parse(response.text || "{}");
};

/**
 * Generates an image using Gemini 2.5 Flash Image model.
 * Returns a base64 data URL.
 */
export const generateAiImage = async (prompt: string, aspectRatio: "1:1" | "4:3" | "16:9" | "9:16" = "1:1"): Promise<string> => {
  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    contents: {
      parts: [{ text: prompt }],
    },
    config: {
      imageConfig: {
        aspectRatio: aspectRatio,
      },
    },
  });

  for (const candidate of response.candidates || []) {
    for (const part of candidate.content.parts) {
      if (part.inlineData) {
        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
  }
  
  throw new Error("No image was generated by the AI.");
};

/**
 * Compresses and optimizes the entire ebook content for commercial sale.
 * It refines the language, optimizes titles, and ensures a high-quality "premium" feel.
 */
export const optimizeEbook = async (ebook: Ebook): Promise<Ebook> => {
  const contentToOptimize = ebook.pages.map((page, idx) => ({
    pageIndex: idx,
    elements: page.elements.filter(el => el.type !== ElementType.IMAGE).map(el => ({
      id: el.id,
      type: el.type,
      content: el.content
    }))
  }));

  const prompt = `You are a world-class ebook publisher and sales copywriter. 
  Your goal is to optimize the following ebook content for selling.
  - Make titles and headings more compelling and "click-worthy".
  - Refine body text to be persuasive, professional, and clear.
  - Maintain the existing structure but elevate the quality of the prose to a premium commercial level.
  - Return ONLY the updated text content for each element.
  
  Ebook Title: ${ebook.title}
  Current Content: ${JSON.stringify(contentToOptimize)}`;

  const response = await ai.models.generateContent({
    model: "gemini-3-pro-preview",
    contents: prompt,
    config: {
      thinkingConfig: { thinkingBudget: 4000 },
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            pageIndex: { type: Type.INTEGER },
            updates: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  id: { type: Type.STRING },
                  optimizedContent: { type: Type.STRING }
                },
                required: ["id", "optimizedContent"]
              }
            }
          },
          required: ["pageIndex", "updates"]
        }
      }
    }
  });

  const optimizationResults = JSON.parse(response.text || "[]");
  const newEbook = { ...ebook };

  optimizationResults.forEach((pageUpdate: any) => {
    const page = newEbook.pages[pageUpdate.pageIndex];
    if (page) {
      page.elements = page.elements.map(el => {
        const update = pageUpdate.updates.find((u: any) => u.id === el.id);
        return update ? { ...el, content: update.optimizedContent } : el;
      });
    }
  });

  return newEbook;
};
